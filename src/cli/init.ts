/**
 * Project init context generation, git snapshot helpers, change entry tracking.
 */

import { spawnSync } from 'node:child_process';
import fs from 'node:fs/promises';
import path from 'node:path';

// ── Init context ─────────────────────────────────────────────────────

type InitProjectSummary = {
  content: string;
  tokenEstimate: number;
};

export async function collectProjectTree(cwd: string): Promise<string[]> {
  const out: string[] = [];
  const top = await fs.readdir(cwd, { withFileTypes: true }).catch(() => [] as any[]);
  for (const e of top) {
    if (e.name.startsWith('.')) continue;
    const rel = e.name;
    if (e.isFile()) {
      out.push(`- ${rel}`);
      continue;
    }
    if (e.isDirectory()) {
      out.push(`- ${rel}/`);
      const nested = await fs
        .readdir(path.join(cwd, rel), { withFileTypes: true })
        .catch(() => [] as any[]);
      for (const n of nested.slice(0, 8)) {
        if (n.name.startsWith('.')) continue;
        out.push(`  - ${rel}/${n.name}${n.isDirectory() ? '/' : ''}`);
      }
    }
  }
  return out.slice(0, 40);
}

export async function detectProjectLanguages(cwd: string): Promise<string[]> {
  const exts = new Map<string, string>([
    ['.ts', 'TypeScript'],
    ['.tsx', 'TypeScript'],
    ['.js', 'JavaScript'],
    ['.jsx', 'JavaScript'],
    ['.py', 'Python'],
    ['.rs', 'Rust'],
    ['.go', 'Go'],
    ['.cs', 'C#'],
    ['.php', 'PHP'],
    ['.java', 'Java'],
    ['.kt', 'Kotlin'],
    ['.c', 'C'],
    ['.cpp', 'C++'],
    ['.h', 'C/C++'],
    ['.swift', 'Swift'],
    ['.rb', 'Ruby'],
    ['.sh', 'Shell'],
    ['.yaml', 'YAML'],
    ['.yml', 'YAML'],
  ]);
  const found = new Set<string>();
  for await (const rel of fs.glob('**/*', {
    cwd,
    exclude: ['**/node_modules/**', '**/.git/**', '**/dist/**', '**/build/**'],
  })) {
    const ext = path.extname(String(rel)).toLowerCase();
    const lang = exts.get(ext);
    if (lang) found.add(lang);
    if (found.size >= 8) break;
  }
  return [...found];
}

export async function generateInitContext(cwd: string): Promise<InitProjectSummary> {
  const has = async (name: string) => {
    try {
      await fs.access(path.join(cwd, name));
      return true;
    } catch {
      return false;
    }
  };

  const projectName = path.basename(cwd);
  const tree = await collectProjectTree(cwd);
  const langs = await detectProjectLanguages(cwd);

  const readmePath = (await has('README.md'))
    ? 'README.md'
    : (await has('readme.md'))
      ? 'readme.md'
      : '';
  let readmePreview = '';
  if (readmePath) {
    const raw = await fs.readFile(path.join(cwd, readmePath), 'utf8').catch(() => '');
    readmePreview = raw.split(/\r?\n/).slice(0, 50).join('\n').trim();
  }

  const buildHints: string[] = [];
  const testHints: string[] = [];
  if (await has('package.json')) {
    buildHints.push('npm run build');
    testHints.push('npm test');
  }
  if (await has('Cargo.toml')) {
    buildHints.push('cargo build');
    testHints.push('cargo test');
  }
  if (await has('go.mod')) {
    buildHints.push('go build ./...');
    testHints.push('go test ./...');
  }
  if (await has('Makefile')) {
    buildHints.push('make');
    testHints.push('make test');
  }
  if ((await has('pyproject.toml')) || (await has('requirements.txt'))) {
    buildHints.push('python -m build (if configured)');
    testHints.push('pytest');
  }

  const content = [
    `# Project: ${projectName}`,
    '',
    `Auto-generated by /init on ${new Date().toISOString()}.`,
    '',
    '## Stack',
    langs.length ? `- Languages: ${langs.join(', ')}` : '- Languages: (not detected)',
    '',
    '## Structure (depth 2)',
    ...(tree.length ? tree : ['- (empty)']),
    '',
    '## Build & Test Hints',
    ...(buildHints.length
      ? buildHints.map((x) => `- Build: \`${x}\``)
      : ['- Build: (not detected)']),
    ...(testHints.length ? testHints.map((x) => `- Test: \`${x}\``) : ['- Test: (not detected)']),
    '',
    '## README preview (first 50 lines)',
    readmePreview ? '```markdown\n' + readmePreview + '\n```' : '_No README found._',
    '',
    '## Key patterns',
    '- Keep this file concise and task-oriented.',
    '- Add project-specific commands and architecture notes here over time.',
  ].join('\n');

  return { content, tokenEstimate: Math.ceil(content.length / 4) };
}

export function formatInitSummary(summary: InitProjectSummary): string {
  return summary.content.endsWith('\n') ? summary.content : summary.content + '\n';
}

// ── Git helpers ──────────────────────────────────────────────────────

export function getGitSnapshot(cwd: string): { status: string; diffStat: string } {
  const status = spawnSync('bash', ['-c', 'git status -s'], {
    cwd,
    encoding: 'utf8',
    timeout: 2000,
  });
  const diffStat = spawnSync('bash', ['-c', 'git diff --stat'], {
    cwd,
    encoding: 'utf8',
    timeout: 2000,
  });
  return {
    status: status.status === 0 ? String(status.stdout || '').trim() : '',
    diffStat: diffStat.status === 0 ? String(diffStat.stdout || '').trim() : '',
  };
}

export function getGitShortStat(cwd: string): string {
  const short = spawnSync('bash', ['-c', 'git diff --shortstat'], {
    cwd,
    encoding: 'utf8',
    timeout: 2000,
  });
  return short.status === 0 ? String(short.stdout || '').trim() : '';
}

export function parseChangedFileCount(shortStat: string): number {
  const m = shortStat.match(/(\d+)\s+files? changed/i);
  if (!m) return 0;
  return Number(m[1]) || 0;
}

export function countDiffAddsRemoves(diff: string): { adds: number; removes: number } {
  let adds = 0;
  let removes = 0;
  for (const line of diff.split(/\r?\n/)) {
    if (line.startsWith('+++') || line.startsWith('---') || line.startsWith('@@')) continue;
    if (line.startsWith('+')) adds++;
    if (line.startsWith('-')) removes++;
  }
  return { adds, removes };
}

// ── Change entries (replay + git) ────────────────────────────────────

export type ChangeEntry = {
  filePath: string;
  edits: number;
  opHint?: string;
};

export async function buildReplayChangeEntries(
  replay: any,
  sinceMs?: number,
  lastN?: number
): Promise<ChangeEntry[]> {
  if (!replay) return [];
  const cps = await replay.list(10000);
  let rows = cps
    .map((cp: any) => ({ ...cp, ms: Date.parse(cp.ts || '') }))
    .filter((cp: any) => Number.isFinite(cp.ms));

  if (sinceMs) rows = rows.filter((cp: any) => cp.ms >= sinceMs);
  if (lastN && lastN > 0) rows = rows.slice(0, lastN);

  const byFile = new Map<string, ChangeEntry>();
  for (const cp of rows) {
    if (!cp.filePath) continue;
    const cur = byFile.get(cp.filePath) ?? { filePath: cp.filePath, edits: 0, opHint: cp.op };
    cur.edits += 1;
    byFile.set(cp.filePath, cur);
  }
  return [...byFile.values()].sort((a, b) => a.filePath.localeCompare(b.filePath));
}

export function getGitNumstatMap(cwd: string): Map<string, { adds: number; removes: number }> {
  const run = spawnSync('bash', ['-c', 'git diff --numstat'], {
    cwd,
    encoding: 'utf8',
    timeout: 2500,
  });
  const out = run.status === 0 ? String(run.stdout || '') : '';
  const map = new Map<string, { adds: number; removes: number }>();
  for (const line of out.split(/\r?\n/)) {
    if (!line.trim()) continue;
    const parts = line.split(/\t/);
    if (parts.length < 3) continue;
    const adds = Number(parts[0]) || 0;
    const removes = Number(parts[1]) || 0;
    const filePath = parts.slice(2).join('\t');
    map.set(filePath, { adds, removes });
  }
  return map;
}

export function getGitPorcelainMap(cwd: string): Map<string, string> {
  const run = spawnSync('bash', ['-c', 'git status --porcelain'], {
    cwd,
    encoding: 'utf8',
    timeout: 2500,
  });
  const out = run.status === 0 ? String(run.stdout || '') : '';
  const map = new Map<string, string>();
  for (const line of out.split(/\r?\n/)) {
    if (!line.trim() || line.length < 4) continue;
    const status = line.slice(0, 2);
    const filePath = line.slice(3).trim();
    map.set(filePath, status);
  }
  return map;
}

export function formatChangePrefix(statusCode?: string): string {
  if (!statusCode) return '✎';
  if (statusCode.includes('??')) return '+';
  if (statusCode.includes('D')) return '−';
  if (statusCode.includes('A')) return '+';
  return '✎';
}
